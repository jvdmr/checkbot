.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "URI::Find 3"
.TH URI::Find 3 "2004-10-11" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
.Vb 1
\&  URI::Find - Find URIs in arbitrary text
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  require URI::Find;
.Ve
.PP
.Vb 1
\&  my $finder = URI::Find->new(\e&callback);
.Ve
.PP
.Vb 1
\&  $how_many_found = $finder->find(\e$text);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module does one thing: Finds URIs and URLs in plain text.  It finds
them quickly and it finds them \fBall\fR (or what \s-1URI::URL\s0 considers a \s-1URI\s0
to be.)  It only finds URIs which include a scheme (http:// or the
like), for something a bit less strict have a look at
URI::Find::Schemeless.
.Sh "Public Methods"
.IX Subsection "Public Methods"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&  my $finder = URI::Find->new(\e&callback);
.Ve
.Sp
Creates a new URI::Find object.
.Sp
&callback is a function which is called on each \s-1URI\s0 found.  It is
passed two arguments, the first is a \s-1URI::URL\s0 object representing the
\&\s-1URI\s0 found.  The second is the original text of the \s-1URI\s0 found.  The
return value of the callback will replace the original \s-1URI\s0 in the
text.
.IP "\fBfind\fR" 4
.IX Item "find"
.Vb 1
\&  my $how_many_found = $finder->find(\e$text);
.Ve
.Sp
$text is a string to search and possibly modify with your callback.
.Sh "Protected Methods"
.IX Subsection "Protected Methods"
I got a bunch of mail from people asking if I'd add certain features
to URI::Find.  Most wanted the search to be less restrictive, do more
heuristics, etc...  Since many of the requests were contradictory, I'm
letting people create their own custom subclasses to do what they
want.
.PP
The following are methods internal to URI::Find which a subclass can
override to change the way URI::Find acts.  They are only to be called
\&\fBinside\fR a URI::Find subclass.  Users of this module are \s-1NOT\s0 to use
these methods.
.IP "\fBuri_re\fR" 4
.IX Item "uri_re"
.Vb 1
\&  my $uri_re = $self->uri_re;
.Ve
.Sp
Returns the regex for finding absolute, schemed URIs
(http://www.foo.com and such).  This, combined with
\&\fIschemeless_uri_re()\fR is what finds candidate URIs.
.Sp
Usually this method does not have to be overridden.
.IP "\fBschemeless_uri_re\fR" 4
.IX Item "schemeless_uri_re"
.Vb 1
\&  my $schemeless_re = $self->schemeless_uri_re;
.Ve
.Sp
Returns the regex for finding schemeless URIs (www.foo.com and such) and
other things which might be URIs.  By default this will match othing
(though it used to try to find schemeless URIs which started with \f(CW\*(C`www\*(C'\fR
and \f(CW\*(C`ftp\*(C'\fR).
.Sp
Many people will want to override this method.  See URI::Find::Schemeless
for a subclass does a reasonable job of finding URIs which might be missing
the scheme.
.IP "\fBuric_set\fR" 4
.IX Item "uric_set"
.Vb 1
\&  my $uric_set = $self->uric_set;
.Ve
.Sp
Returns a set matching the 'uric' set defined in \s-1RFC\s0 2396 suitable for
putting into a character set ([]) in a regex.
.Sp
You almost never have to override this.
.IP "\fBcruft_set\fR" 4
.IX Item "cruft_set"
.Vb 1
\&  my $cruft_set = $self->cruft_set;
.Ve
.Sp
Returns a set of characters which are considered garbage.  Used by
\&\fIdecruft()\fR.
.IP "\fBdecruft\fR" 4
.IX Item "decruft"
.Vb 1
\&  my $uri = $self->decruft($uri);
.Ve
.Sp
Sometimes garbage characters like periods and parenthesis get
accidentally matched along with the \s-1URI\s0.  In order for the \s-1URI\s0 to be
properly identified, it must sometimes be \*(L"decrufted\*(R", the garbage
characters stripped.
.Sp
This method takes a candidate \s-1URI\s0 and strips off any cruft it finds.
.IP "\fBrecruft\fR" 4
.IX Item "recruft"
.Vb 1
\&  my $uri = $self->recruft($uri);
.Ve
.Sp
This method puts back the cruft taken off with \fIdecruft()\fR.  This is necessary
because the cruft is destructively removed from the string before invoking
the user's callback, so it has to be put back afterwards.
.IP "\fBschemeless_to_schemed\fR" 4
.IX Item "schemeless_to_schemed"
.Vb 1
\&  my $schemed_uri = $self->schemeless_to_schemed($schemeless_uri);
.Ve
.Sp
This takes a schemeless \s-1URI\s0 and returns an absolute, schemed \s-1URI\s0.  The
standard implementation supplies ftp:// for URIs which start with ftp.,
and http:// otherwise.
.IP "\fBis_schemed\fR" 4
.IX Item "is_schemed"
.Vb 1
\&  $obj->is_schemed($uri);
.Ve
.Sp
Returns whether or not the given \s-1URI\s0 is schemed or schemeless.  True for
schemed, false for schemeless.
.Sh "Old Functions"
.IX Subsection "Old Functions"
The old \fIfind_uri()\fR function is still around and it works, but its
deprecated.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Simply print the original \s-1URI\s0 text found and the normalized
representation.
.PP
.Vb 7
\&  my $finder = URI::Find->new(
\&                      sub {
\&                          my($uri, $orig_uri) = @_;
\&                          print "The text '$orig_uri' represents '$uri'\en";
\&                          return $orig_uri;
\&                      });
\&  $finder->find(\e$text);
.Ve
.PP
Check each \s-1URI\s0 in document to see if it exists.
.PP
.Vb 1
\&  use LWP::Simple;
.Ve
.PP
.Vb 11
\&  my $finder = URI::Find->new(sub {
\&                                  my($uri, $orig_uri) = @_;
\&                                  if( head $uri ) {
\&                                      print "$orig_uri is okay\en";
\&                                  }
\&                                  else {
\&                                      print "$orig_uri cannot be found\en";
\&                                  }
\&                                  return $orig_uri;
\&                              });
\&  $finder->find(\e$text);
.Ve
.PP
Turn plain text into \s-1HTML\s0, with each \s-1URI\s0 found wrapped in an \s-1HTML\s0 anchor.
.PP
.Vb 1
\&  use CGI qw(escapeHTML);
.Ve
.PP
.Vb 7
\&  $text = "<pre>\en" . escapeHTML($text) . "</pre>\en";
\&  my $finder = URI::Find->new(
\&                              sub {
\&                                  my($uri, $orig_uri) = @_;
\&                                  return qq|<a href="$uri">$orig_uri</a>|;
\&                              });
\&  $finder->find(\e$text);
.Ve
.SH "CAVEATS, BUGS, ETC..."
.IX Header "CAVEATS, BUGS, ETC..."
\&\s-1RFC\s0 2396 Appendix E suggests using the form '<http://www.foo.com>' or
\&'<URL:http://www.foo.com>' when putting URLs in plain text.  URI::Find
accomidates this suggestion and considers the entire thing (brackets
and all) to be part of the \s-1URL\s0 found.  This means that when
\&\fIfind_uris()\fR sees '<URL:http://www.foo.com>' it will hand that entire
string to your callback, not just the \s-1URL\s0.
.PP
\&\s-1NOTE:\s0  The prototype on \fIfind_uris()\fR is already getting annoying to me.
I might remove it in a future version.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 2
\&  L<URI::Find::Schemeless>, L<URI::URL>, L<URI>,
\&  RFC 2396 (especially Appendix E)
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com> with insight from Uri Gutman,
Greg Bacon, Jeff Pinyan, Roderick Schertler and others.
.PP
Currently maintained by Roderick Schertler <roderick@argon.org>.
